"""
Visualiseur progressif pour l'apprentissage modulaire avec intensit√©s variables.
Migr√© depuis visualize_modular_progressive_obstacles_variable_intensity.py
"""

import torch
import matplotlib.pyplot as plt
import numpy as np
from typing import List, Optional, Dict, Any
from pathlib import Path


class ProgressiveVisualizer:
    """
    Syst√®me de visualisation avanc√© pour l'apprentissage modulaire avec intensit√©s variables.
    √âtend les fonctionnalit√©s v7__ avec support des intensit√©s variables.
    """
    
    def __init__(self, interactive: bool = False):
        self.interactive = interactive
        self.frame_data = {}  # Donn√©es par √©tape
        self.intensity_data = {}  # Donn√©es d'intensit√© par √©tape
        
    def visualize_stage_results(self, model, stage: int, simulator, cfg,
                              vis_seed: int = 123, source_intensity: Optional[float] = None) -> Dict[str, Any]:
        """
        Visualise les r√©sultats d'une √©tape avec support intensit√© variable.
        
        Args:
            model: Mod√®le NCA entra√Æn√©
            stage: Num√©ro d'√©tape (1-4)
            simulator: Simulateur de diffusion
            cfg: Configuration
            vis_seed: Graine pour reproductibilit√©
            source_intensity: Intensit√© sp√©cifique pour √©tape 4 (None = intensit√© standard)
            
        Returns:
            Dictionnaire avec donn√©es de visualisation √©tendues
        """
        print(f"\nüé® G√©n√©ration des visualisations pour l'√©tape {stage}...")
        
        # G√©n√©ration de la s√©quence de test avec seed fixe
        torch.manual_seed(vis_seed)
        np.random.seed(vis_seed)
        
        # G√©n√©ration adapt√©e selon l'√©tape
        if stage == 4 and source_intensity is not None:
            # √âtape 4: utilise l'intensit√© sp√©cifi√©e
            target_seq, source_mask, obstacle_mask, used_intensity = simulator.generate_stage_sequence(
                stage=4, n_steps=cfg.POSTVIS_STEPS, size=cfg.GRID_SIZE,
                seed=vis_seed, source_intensity=source_intensity)
        else:
            # √âtapes 1-3: intensit√© standard
            target_seq, source_mask, obstacle_mask, used_intensity = simulator.generate_stage_sequence(
                stage=stage, n_steps=cfg.POSTVIS_STEPS, size=cfg.GRID_SIZE, seed=vis_seed)
            if used_intensity is None:
                used_intensity = cfg.DEFAULT_SOURCE_INTENSITY

        # Simulation NCA avec intensit√© appropri√©e
        nca_sequence = self._simulate_nca_with_intensity(model, target_seq[0],
                                                       source_mask, obstacle_mask,
                                                       used_intensity, cfg)
        
        # Donn√©es de visualisation √©tendues
        vis_data = {
            'stage': stage,
            'target_sequence': [t.detach().cpu().numpy() for t in target_seq],
            'nca_sequence': [t.detach().cpu().numpy() for t in nca_sequence],
            'source_mask': source_mask.detach().cpu().numpy(),
            'obstacle_mask': obstacle_mask.detach().cpu().numpy(),
            'source_intensity': used_intensity,  # NOUVEAU
            'vis_seed': vis_seed
        }
        
        # Cr√©ation des visualisations avec intensit√©
        self._create_stage_animations_with_intensity(vis_data, cfg)
        self._create_stage_convergence_plot_with_intensity(vis_data, cfg)
        
        model.train()
        return vis_data
    
    def _simulate_nca_with_intensity(self, model, initial_grid, source_mask, obstacle_mask,
                                   source_intensity: float, cfg) -> List[torch.Tensor]:
        """
        Simule le NCA avec une intensit√© sp√©cifique.
        """
        # Import dynamique pour √©viter les d√©pendances circulaires
        try:
            from .. import OptimizedNCAUpdater, NCAUpdater
        except ImportError:
            # Fallback si import relatif √©choue
            try:
                from __main__ import OptimizedNCAUpdater, NCAUpdater
            except ImportError:
                # Cr√©er un updater basique si n√©cessaire
                class BasicNCAUpdater:
                    def __init__(self, model, device):
                        self.model = model
                        self.device = device
                    
                    def step(self, grid, source_mask, obstacle_mask, source_intensity=None):
                        # Version simplifi√©e pour la visualisation
                        with torch.no_grad():
                            new_grid = grid.clone()
                            if source_intensity is not None:
                                new_grid[source_mask] = source_intensity
                            else:
                                new_grid[source_mask] = cfg.SOURCE_INTENSITY
                        return new_grid
                
                OptimizedNCAUpdater = BasicNCAUpdater
        
        model.eval()
        updater = OptimizedNCAUpdater(model, cfg.DEVICE) if hasattr(cfg, 'USE_OPTIMIZATIONS') and cfg.USE_OPTIMIZATIONS else None
        
        if updater is None:
            # Fallback simple
            updater = type('SimpleUpdater', (), {
                'step': lambda self, grid, source_mask, obstacle_mask, source_intensity=None: self._simple_step(grid, source_mask, obstacle_mask, source_intensity, cfg)
            })()
            updater._simple_step = lambda grid, source_mask, obstacle_mask, source_intensity, cfg: self._simple_nca_step(grid, source_mask, obstacle_mask, source_intensity, cfg)
        
        # Simulation NCA
        nca_sequence = []
        grid_pred = torch.zeros_like(initial_grid)
        grid_pred[source_mask] = source_intensity
        nca_sequence.append(grid_pred.clone())
        
        with torch.no_grad():
            for _ in range(cfg.POSTVIS_STEPS):
                if hasattr(updater, 'step'):
                    grid_pred = updater.step(grid_pred, source_mask, obstacle_mask, source_intensity)
                else:
                    grid_pred = self._simple_nca_step(grid_pred, source_mask, obstacle_mask, source_intensity, cfg)
                nca_sequence.append(grid_pred.clone())
        
        return nca_sequence
    
    def _simple_nca_step(self, grid, source_mask, obstacle_mask, source_intensity, cfg):
        """Version simplifi√©e d'un pas NCA pour la visualisation."""
        new_grid = grid.clone()
        if source_intensity is not None:
            new_grid[source_mask] = source_intensity
        return new_grid
    
    def _create_stage_animations_with_intensity(self, vis_data: Dict[str, Any], cfg):
        """Cr√©e les animations GIF pour une √©tape avec affichage d'intensit√©."""
        # Import local pour √©viter les d√©pendances circulaires
        from .intensity_animator import IntensityAwareAnimator
        
        stage = vis_data['stage']
        intensity = vis_data['source_intensity']
        
        # Cr√©ation du r√©pertoire de sortie
        if stage == 4:
            stage_dir = Path(cfg.OUTPUT_DIR) / f"stage_{stage}"
            intensity_suffix = f"_I_{intensity:.3f}"
        else:
            stage_dir = Path(cfg.OUTPUT_DIR) / f"stage_{stage}"
            intensity_suffix = ""
            
        stage_dir.mkdir(parents=True, exist_ok=True)
        
        # Animation comparative avec intensit√©
        animator = IntensityAwareAnimator()
        
        comparison_path = stage_dir / f"animation_comparaison_√©tape_{stage}{intensity_suffix}.gif"
        animator.create_comparison_with_intensity(
            vis_data['target_sequence'],
            vis_data['nca_sequence'],
            vis_data['obstacle_mask'],
            intensity,
            comparison_path
        )
        
        # Animation NCA seule avec intensit√©
        nca_path = stage_dir / f"animation_nca_√©tape_{stage}{intensity_suffix}.gif"
        animator.create_intensity_labeled_gif(
            vis_data['nca_sequence'],
            vis_data['obstacle_mask'],
            intensity,
            nca_path,
            f"√âtape {stage} - NCA"
        )
        
        print(f"‚úÖ Animations √©tape {stage} (I={intensity:.3f}) sauvegard√©es dans {stage_dir}")
    
    def _create_stage_convergence_plot_with_intensity(self, vis_data: Dict[str, Any], cfg):
        """Cr√©e le graphique de convergence pour une √©tape avec intensit√©."""
        stage = vis_data['stage']
        intensity = vis_data['source_intensity']
        
        if stage == 4:
            stage_dir = Path(cfg.OUTPUT_DIR) / f"stage_{stage}"
            intensity_suffix = f"_I_{intensity:.3f}"
        else:
            stage_dir = Path(cfg.OUTPUT_DIR) / f"stage_{stage}"
            intensity_suffix = ""
            
        target_seq = vis_data['target_sequence']
        nca_seq = vis_data['nca_sequence']
        
        # Calcul de l'erreur temporelle
        errors = []
        for t in range(min(len(target_seq), len(nca_seq))):
            error = np.mean((target_seq[t] - nca_seq[t]) ** 2)
            errors.append(error)
        
        # Graphique avec intensit√© dans le titre
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(errors, 'b-', linewidth=2, label='Erreur MSE')
        
        # Seuil de convergence - utilise la nouvelle m√©thode au lieu de l'attribut dupliqu√©
        threshold = cfg.get_convergence_threshold(stage, getattr(cfg, 'stage_manager', None))
        ax.axhline(y=threshold, color='r', linestyle='--',
                  label=f'Seuil convergence √©tape {stage}')
        
        ax.set_xlabel('Pas de temps')
        ax.set_ylabel('Erreur MSE')
        ax.set_title(f'Convergence √âtape {stage} (I={intensity:.3f}) - Seed {vis_data["vis_seed"]}')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        convergence_path = stage_dir / f"convergence_√©tape_{stage}{intensity_suffix}.png"
        plt.savefig(convergence_path, dpi=150, bbox_inches='tight')
        plt.close()
        
        print(f"‚úÖ Graphique de convergence √©tape {stage} (I={intensity:.3f}) sauvegard√©: {convergence_path}")
    
    def create_intensity_comparison_grid(self, model, simulator, cfg,
                                       intensity_samples: Optional[List[float]] = None,
                                       vis_seed: int = 123):
        """
        Cr√©e une grille comparative pour diff√©rentes intensit√©s (√âtape 4).
        """
        if intensity_samples is None:
            intensity_samples = [0.0, 0.25, 0.5, 0.75, 1.0]
        
        print("üé® G√©n√©ration de la grille comparative d'intensit√©s...")
        
        fig, axes = plt.subplots(2, len(intensity_samples), figsize=(4*len(intensity_samples), 8))
        
        if len(intensity_samples) == 1:
            axes = axes.reshape(-1, 1)
        
        # Initialisation des variables pour les colorbars
        im1 = None
        im2 = None
        
        for i, intensity in enumerate(intensity_samples):
            # G√©n√©ration avec intensit√© sp√©cifique
            vis_data = self.visualize_stage_results(model, stage=4, simulator=simulator, cfg=cfg,
                                                  vis_seed=vis_seed, source_intensity=intensity)
            
            # √âtat initial
            im1 = axes[0, i].imshow(vis_data['nca_sequence'][0], cmap='hot', vmin=0, vmax=1)
            axes[0, i].contour(vis_data['obstacle_mask'], levels=[0.5], colors='cyan', linewidths=2)
            axes[0, i].set_title(f'Initial (I={intensity:.3f})', fontweight='bold')
            axes[0, i].set_xticks([])
            axes[0, i].set_yticks([])
            
            # √âtat final
            im2 = axes[1, i].imshow(vis_data['nca_sequence'][-1], cmap='hot', vmin=0, vmax=1)
            axes[1, i].contour(vis_data['obstacle_mask'], levels=[0.5], colors='cyan', linewidths=2)
            axes[1, i].set_title(f'Final (I={intensity:.3f})', fontweight='bold')
            axes[1, i].set_xticks([])
            axes[1, i].set_yticks([])
        
        # Ajout des colorbars seulement si on a des images
        if im1 is not None and im2 is not None:
            fig.colorbar(im1, ax=axes[0, :], shrink=0.6, aspect=20)
            fig.colorbar(im2, ax=axes[1, :], shrink=0.6, aspect=20)
        
        plt.suptitle('Comparaison d\'Intensit√©s - √âtape 4', fontsize=16, fontweight='bold')
        plt.tight_layout()
        plt.savefig(Path(cfg.OUTPUT_DIR) / "intensity_comparison_grid.png",
                   dpi=150, bbox_inches='tight')
        plt.close()
        
        print("‚úÖ Grille comparative d'intensit√©s g√©n√©r√©e")
    
    def visualize_intensity_curriculum(self, stage_4_metrics: Dict[str, Any], cfg):
        """
        Visualise le curriculum d'intensit√© de l'√©tape 4.
        """
        # Import local pour √©viter les d√©pendances circulaires
        from .metrics_plotter import VariableIntensityMetricsPlotter
        
        print("üé® G√©n√©ration des graphiques de curriculum d'intensit√©...")
        
        output_dir = Path(cfg.OUTPUT_DIR)
        metrics_plotter = VariableIntensityMetricsPlotter()
        
        if 'intensity_history' in stage_4_metrics:
            metrics_plotter.plot_intensity_distribution(
                stage_4_metrics['intensity_history'], output_dir)
        
        if 'performance_by_intensity' in stage_4_metrics:
            metrics_plotter.plot_performance_by_intensity_range(
                stage_4_metrics['performance_by_intensity'], output_dir)
        
        if 'convergence_analysis' in stage_4_metrics:
            metrics_plotter.plot_convergence_analysis_by_intensity(
                stage_4_metrics['convergence_analysis'], output_dir)

    def create_curriculum_summary_extended(self, global_metrics: Dict[str, Any], cfg):
        """Cr√©e un r√©sum√© visuel complet du curriculum d'apprentissage √©tendu (v8__)."""
        print("\nüé® G√©n√©ration du r√©sum√© visuel du curriculum √©tendu...")
        
        # Graphique de progression globale √©tendu (4 √©tapes)
        self._plot_curriculum_progression_extended(global_metrics, cfg)
        
        # Comparaison inter-√©tapes √©tendue
        self._plot_stage_comparison_extended(global_metrics, cfg)
        
        # M√©triques de performance √©tendues
        self._plot_performance_metrics_extended(global_metrics, cfg)
        
        print("‚úÖ R√©sum√© visuel complet √©tendu g√©n√©r√©")
    
    def _plot_curriculum_progression_extended(self, metrics: Dict[str, Any], cfg):
        """Graphique de la progression globale du curriculum √©tendu (4 √©tapes)."""
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(14, 10))
        
        # Historique des pertes avec codes couleur par √©tape (4 √©tapes)
        if 'global_history' in metrics:
            losses = metrics['global_history']['losses']
            stages = metrics['global_history']['stages']
            epochs = metrics['global_history']['epochs']
            
            stage_colors = {1: 'green', 2: 'orange', 3: 'red', 4: 'purple'}
            stage_names = {1: 'Sans obstacles', 2: 'Un obstacle', 3: 'Obstacles multiples', 4: 'Intensit√©s variables'}
            
            for stage in [1, 2, 3, 4]:
                stage_indices = [i for i, s in enumerate(stages) if s == stage]
                if stage_indices:
                    stage_losses = [losses[i] for i in stage_indices]
                    stage_epochs = [epochs[i] for i in stage_indices]
                    
                    ax1.plot(stage_epochs, stage_losses,
                            color=stage_colors[stage],
                            label=f'√âtape {stage} ({stage_names[stage]})',
                            linewidth=2)
            
            # Seuils de convergence - utilise la nouvelle m√©thode au lieu de l'attribut dupliqu√©
            for stage in [1, 2, 3, 4]:
                threshold = cfg.get_convergence_threshold(stage, getattr(cfg, 'stage_manager', None))
                if threshold != 0.05:  # Seulement si diff√©rent de la valeur par d√©faut
                    ax1.axhline(y=threshold, color=stage_colors[stage],
                               linestyle='--', alpha=0.7,
                               label=f'Seuil √©tape {stage}')
        
        ax1.set_xlabel('√âpoque')
        ax1.set_ylabel('Perte MSE')
        ax1.set_title('Progression du Curriculum d\'Apprentissage √âtendu (4 √âtapes)')
        ax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        ax1.grid(True, alpha=0.3)
        ax1.set_yscale('log')
        
        # Learning rate par √©tape
        if 'stage_histories' in metrics:
            stage_colors = {1: 'green', 2: 'orange', 3: 'red', 4: 'purple'}
            for stage in [1, 2, 3, 4]:
                if stage in metrics['stage_histories']:
                    stage_history = metrics['stage_histories'][stage]
                    if 'lr' in stage_history and stage_history['lr']:
                        stage_start = metrics.get('stage_start_epochs', {}).get(stage, 0)
                        stage_epochs_local = [stage_start + e for e in stage_history['epochs']]
                        ax2.plot(stage_epochs_local, stage_history['lr'],
                                color=stage_colors[stage],
                                label=f'LR √âtape {stage}',
                                linewidth=2)
        
        ax2.set_xlabel('√âpoque')
        ax2.set_ylabel('Learning Rate')
        ax2.set_title('√âvolution du Learning Rate par √âtape')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        ax2.set_yscale('log')
        
        plt.tight_layout()
        plt.savefig(Path(cfg.OUTPUT_DIR) / "curriculum_progression_extended.png",
                   dpi=150, bbox_inches='tight')
        plt.close()
    
    def _plot_stage_comparison_extended(self, metrics: Dict[str, Any], cfg):
        """Graphique de comparaison entre les 4 √©tapes."""
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))
        
        stages = [1, 2, 3, 4]
        stage_names = ["Sans obstacles", "Un obstacle", "Obstacles multiples", "Intensit√©s variables"]
        stage_colors = ['green', 'orange', 'red', 'purple']
        
        if 'stage_metrics' in metrics:
            # Pertes finales par √©tape
            final_losses = []
            convergence_status = []
            epochs_used = []
            
            for s in stages:
                if s in metrics['stage_metrics']:
                    final_losses.append(metrics['stage_metrics'][s].get('final_loss', 0))
                    convergence_status.append(metrics['stage_metrics'][s].get('convergence_met', False))
                    epochs_used.append(metrics['stage_metrics'][s].get('epochs_trained', 0))
                else:
                    final_losses.append(0)
                    convergence_status.append(False)
                    epochs_used.append(0)
            
            # Graphique des pertes finales
            bars = ax1.bar(stage_names, final_losses, color=stage_colors, alpha=0.7)
            for i, (bar, converged) in enumerate(zip(bars, convergence_status)):
                if converged:
                    bar.set_edgecolor('darkgreen')
                    bar.set_linewidth(3)
            
            ax1.set_ylabel('Perte finale')
            ax1.set_title('Perte Finale par √âtape')
            ax1.set_yscale('log')
            plt.setp(ax1.get_xticklabels(), rotation=15, ha='right')
            
            # √âpoques utilis√©es par √©tape
            epochs_planned = [
                getattr(cfg, 'STAGE_1_EPOCHS', 0),
                getattr(cfg, 'STAGE_2_EPOCHS', 0),
                getattr(cfg, 'STAGE_3_EPOCHS', 0),
                getattr(cfg, 'STAGE_4_EPOCHS', 0)
            ]
            
            x = np.arange(len(stages))
            width = 0.35
            
            ax2.bar(x - width/2, epochs_planned, width, label='Pr√©vues', alpha=0.7, color='lightblue')
            ax2.bar(x + width/2, epochs_used, width, label='Utilis√©es', alpha=0.7, color='darkblue')
            
            ax2.set_xlabel('√âtape')
            ax2.set_ylabel('Nombre d\'√©poques')
            ax2.set_title('√âpoques Pr√©vues vs Utilis√©es')
            ax2.set_xticks(x)
            ax2.set_xticklabels(stage_names, rotation=15, ha='right')
            ax2.legend()
            
            # Temps de convergence
            convergence_times = []
            for stage in stages:
                if stage in metrics['stage_metrics'] and 'loss_history' in metrics['stage_metrics'][stage]:
                    stage_losses = metrics['stage_metrics'][stage]['loss_history']
                    threshold = cfg.get_convergence_threshold(stage, getattr(cfg, 'stage_manager', None))
                    
                    convergence_epoch = None
                    for i, loss in enumerate(stage_losses):
                        if loss < threshold:
                            convergence_epoch = i
                            break
                    
                    convergence_times.append(convergence_epoch if convergence_epoch else len(stage_losses))
                else:
                    convergence_times.append(0)
            
            ax3.plot(stages, convergence_times, 'o-', linewidth=2, markersize=8, color='purple')
            ax3.set_xlabel('√âtape')
            ax3.set_ylabel('√âpoque de convergence')
            ax3.set_title('Vitesse de Convergence par √âtape')
            ax3.grid(True, alpha=0.3)
            ax3.set_xticks(stages)
            
            # Efficacit√© (convergence / √©poques utilis√©es)
            efficiency = []
            for i in range(len(stages)):
                if epochs_used[i] > 0:
                    eff = (1.0 if convergence_status[i] else 0.5) / epochs_used[i]
                    efficiency.append(eff)
                else:
                    efficiency.append(0)
            
            ax4.bar(stage_names, efficiency, color=stage_colors, alpha=0.7)
            ax4.set_ylabel('Efficacit√© (convergence/√©poque)')
            ax4.set_title('Efficacit√© d\'Apprentissage par √âtape')
            plt.setp(ax4.get_xticklabels(), rotation=15, ha='right')
        
        plt.tight_layout()
        plt.savefig(Path(cfg.OUTPUT_DIR) / "stage_comparison_extended.png",
                   dpi=150, bbox_inches='tight')
        plt.close()
    
    def _plot_performance_metrics_extended(self, metrics: Dict[str, Any], cfg):
        """Graphique des m√©triques de performance globales √©tendues."""
        fig, ax = plt.subplots(figsize=(12, 10))
        
        # R√©sum√© textuel des performances √©tendu
        total_time = metrics.get('total_time_seconds', 0)
        total_epochs = metrics.get('total_epochs_actual', 0)
        all_converged = metrics.get('all_stages_converged', False)
        final_loss = metrics.get('final_loss', 0)
        
        summary_text = f"""
üéØ R√âSUM√â ENTRA√éNEMENT MODULAIRE NCA v8__ (INTENSIT√âS VARIABLES)

üìä STATISTIQUES GLOBALES:
   ‚Ä¢ Seed: {cfg.SEED}
   ‚Ä¢ Temps total: {total_time/60:.1f} minutes ({total_time:.1f}s)
   ‚Ä¢ √âpoques totales: {total_epochs}/{cfg.TOTAL_EPOCHS}
   ‚Ä¢ Toutes √©tapes converg√©es: {'‚úÖ OUI' if all_converged else '‚ùå NON'}
   ‚Ä¢ Perte finale: {final_loss:.6f}

üèÜ PERFORMANCE PAR √âTAPE:"""
        
        stage_names = {1: "Sans obstacles", 2: "Un obstacle", 3: "Obstacles multiples", 4: "Intensit√©s variables"}
        
        for stage in [1, 2, 3, 4]:
            if 'stage_metrics' in metrics and stage in metrics['stage_metrics']:
                stage_data = metrics['stage_metrics'][stage]
                stage_name = stage_names[stage]
                
                summary_text += f"""
   ‚Ä¢ √âtape {stage} ({stage_name}):
     - √âpoques: {stage_data.get('epochs_trained', 0)} (converg√©e: {'‚úÖ' if stage_data.get('convergence_met', False) else '‚ùå'})
     - Perte finale: {stage_data.get('final_loss', 0):.6f}
     - Arr√™t pr√©coce: {'‚úÖ' if stage_data.get('early_stopped', False) else '‚ùå'}"""
        
        # Ajout des statistiques d'intensit√© pour l'√©tape 4
        if 'intensity_metrics' in metrics:
            intensity_stats = metrics['intensity_metrics'].get('statistics', {})
            summary_text += f"""

üî• STATISTIQUES INTENSIT√âS (√âTAPE 4):
   ‚Ä¢ Intensit√©s utilis√©es: {intensity_stats.get('count', 0)}
   ‚Ä¢ Intensit√© moyenne: {intensity_stats.get('mean', 0):.3f}
   ‚Ä¢ √âcart-type: {intensity_stats.get('std', 0):.3f}
   ‚Ä¢ Plage: [{intensity_stats.get('min', 0):.3f}, {intensity_stats.get('max', 0):.3f}]"""
        
        summary_text += f"""

‚öôÔ∏è  CONFIGURATION:
   ‚Ä¢ Curriculum learning: {'‚úÖ' if getattr(cfg, 'ENABLE_CURRICULUM', False) else '‚ùå'}
   ‚Ä¢ Intensit√©s variables: {'‚úÖ' if getattr(cfg, 'VARIABLE_INTENSITY_TRAINING', False) else '‚ùå'}
   ‚Ä¢ Cache optimis√©: {'‚úÖ' if getattr(cfg, 'USE_SEQUENCE_CACHE', False) else '‚ùå'}
   ‚Ä¢ Updater vectoris√©: {'‚úÖ' if getattr(cfg, 'USE_VECTORIZED_PATCHES', False) else '‚ùå'}

üìà ARCHITECTURE:
   ‚Ä¢ Taille grille: {cfg.GRID_SIZE}x{cfg.GRID_SIZE}
   ‚Ä¢ Couches cach√©es: {cfg.HIDDEN_SIZE} neurones, {cfg.N_LAYERS} couches
   ‚Ä¢ Pas temporels NCA: {cfg.NCA_STEPS}
   ‚Ä¢ Taille batch: {cfg.BATCH_SIZE}
        """
        
        ax.text(0.05, 0.95, summary_text, transform=ax.transAxes,
               fontsize=9, verticalalignment='top', fontfamily='monospace',
               bbox=dict(boxstyle='round', facecolor='lightgray', alpha=0.8))
        
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.axis('off')
        ax.set_title('R√©sum√© Performance Entra√Ænement Modulaire NCA v8__ (Intensit√©s Variables)',
                    fontsize=14, fontweight='bold')
        
        plt.tight_layout()
        plt.savefig(Path(cfg.OUTPUT_DIR) / "performance_summary_extended.png",
                   dpi=150, bbox_inches='tight')
        plt.close()
